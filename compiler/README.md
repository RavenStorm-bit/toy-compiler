# Compiler Package

The compiler package transforms Abstract Syntax Trees (AST) into bytecode instructions that can be executed by the virtual machine.

## Purpose

The compiler serves as the bridge between the parser output (AST) and the VM input (bytecode). It performs:
- AST traversal
- Bytecode generation
- Constant pool management
- Symbol resolution

## Architecture

### Core Components

1. **Compiler Structure**
   ```go
   type Compiler struct {
       instructions bytecode.Instructions  // Generated bytecode
       constants    []interface{}         // Constant pool
       symbolTable  *SymbolTable          // Variable tracking
   }
   ```

2. **Compilation Phases**
   - AST traversal using visitor pattern
   - Expression compilation
   - Statement compilation
   - Function compilation

### Bytecode Generation Process

1. **Literals**: Push constants to stack
2. **Binary Operations**: Generate arithmetic instructions
3. **Variables**: Generate load/store instructions
4. **Control Flow**: Generate jump instructions
5. **Functions**: Generate call/return instructions

## Implementation Plan

### Phase 1: Basic Expressions
- Integer literals
- Arithmetic operations (+, -, *, /)
- Parenthesized expressions

### Phase 2: Variables
- Variable declarations
- Variable assignments
- Variable references
- Symbol table implementation

### Phase 3: Control Flow
- If/else statements
- Comparison operators
- Conditional jumps
- Loops (while, for)

### Phase 4: Functions
- Function declarations
- Function calls
- Return statements
- Scope management

## Usage Example

```go
// Compile an AST node
compiler := compiler.New()
err := compiler.Compile(astNode)
if err != nil {
    // Handle compilation error
}

// Get the generated bytecode
bytecode := compiler.Bytecode()
```

## Key Methods

- `Compile(node ast.Node) error`: Main compilation entry point
- `Bytecode() *bytecode.Bytecode`: Returns compiled bytecode
- `addConstant(obj interface{}) int`: Adds constant to pool
- `emit(op bytecode.Opcode, operands ...int) int`: Emits instruction

## Error Handling

The compiler should handle:
- Undefined variables
- Type mismatches
- Invalid operations
- Scope violations

## Testing Strategy

1. Unit tests for each node type
2. Integration tests for complex expressions
3. Bytecode verification tests
4. Error case testing
